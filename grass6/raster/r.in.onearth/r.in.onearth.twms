#!/bin/sh
#############################################################################
# Download and import satellite images direct from the                      #
# NASA onearth WMS server into GRASS.                                       #
# written by Soeren Gebbert 11/2005 soerengebbert AT gmx de                 #
# and Markus Neteler. Support for pre-tiled WMS server by Hamish Bowman     #
#                                                                           #
# COPYRIGHT:        (C) 2005-2012 by the GRASS Development Team             #
#                                                                           #
#            This program is free software under the GNU General Public     #
#            License (>=v2). Read the file COPYING that comes with GRASS    #
#            for details.                                                   #
#                                                                           #
#############################################################################

#%Module
#%  description: Download and import satellite images direct from the NASA onearth WMS server into GRASS or to a geo-tiff image file.
#%End
#%option
#%  key: output
#%  gisprompt: new,cell,raster
#%  type: string
#%  description: Output raster map name prefix
#%  required: no
#%end
#%option
#%  key: file
#%  gisprompt: file,file,file
#%  type: string
#%  description: Output file name prefix
#%  answer: /tmp/test
#%  required: no
#%end
#%flag
#%  key: f
#%  description: Do not import to GRASS, create a tiff file instead.
#%end
#%flag
#%  key: l
#%  description: Download and Import WMS Global Mosaic, a High Resolution, Global Coverage, Landsat TM 7 mosaic.
#%end
#%flag
#%  key: s
#%  description: Download and Import the radar reflectance images produced by the SRTM mission.
#%end
#%flag
#%  key: b
#%  description: Download and Import the Blue Marble Next Generation layer, one for each month of the year. 
#%end
#%flag
#%  key: t
#%  description: Download and Import the composite of data produced by the MODIS Rapid Response System, from data collected yesterday by the MODIS/Terra.
#%end
#%flag
#%  key: a
#%  description: Download and Import the composite of data produced by the MODIS Rapid Response System, from data collected yesterday by the MODIS/Aqua.
#%end
#%option
#%  key: tmband
#%  type: string
#%  description: NASA Landsat TM bands
#%  options: Red,Green,Blue,IR1,IR2,IR3,ThL,ThH,Pan,visual,pseudo 
#%  required: no
#%end
#%option
#%  key: srtmband
#%  type: string
#%  description: Radar reflectance bands
#%  options:  default,ss1,ss2,ss3,ss4,all 
#%  required: no
#%end
#%option
#%  key: month
#%  type: string
#%  description: Blue Marble Next Generation layer
#%  options: Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec 
#%  required: no
#%end
#%option
#%  key: time
#%  type: string
#%  description: The datum of creation for Aqua or Terra satellite images
#%  answer: 2005-3-24    
#%  required: no
#%end
#%option
#%  key: wgetopt
#%  type: string
#%  description: Options for wget
#%  answer: -c -t 5
#%  required: no
#%end


#Only run if started in GRASS
if [ -z "$GISBASE" ] ; then
    echo "You must be in GRASS GIS to run this program." >&2
    exit 1
fi

#Parse the arguments
if [ "$1" != "@ARGS_PARSED@" ] ; then
  exec g.parser "$0" "$@"
fi


#Set up important vars first
SRC="EPSG:4326" #This is the Projection LatLong wgs84
FORMAT="image/geotiff" #GeoTiff import for r.in.gdal
NASASERVER="http://wms.jpl.nasa.gov/wms.cgi" #this server may change
TYPE=""
TIME=""
IMPORT=0 #0 is true
GLOBAL_MOSAIC_LAYER="global_mosaic_base" #Thats the NASA WMS Global Mosaic database
SRTM_MAG_LAYER="srtm_mag" #Thats the NASA srtm_mag database
BMNG_LAYER="BMNG" #Thats the Blue Marble Next Generation database
DAILY_TERRA_LAYER="daily_terra" #Thats the NASA daily terra database
DAILY_AQUA_LAYER="daily_aqua" #Thats the NASA daily aqua database
USE_GDALWARP="true" #if we dont have gdalwarp, only LatLong projection is supported
FILE_EXTENT=".tif"


# check if we have wget
if [ ! -x "`which wget`" ] ; then
    g.message -e "wget required, please install first"
    exit 1
fi

# check if we have gdalwarp
if [ ! -x "`which gdalwarp`" ] ; then
    g.message -w "gdalwarp is recommended, please install first (script still works in LatLong locations)"
    USE_GDALWARP="false"  #use only LatLong
fi


############
# for now just support lat/lon
USE_GDALWARP="false"
############

eval `g.region -g`

if [ "$nsres" != "$ewres" ] ; then
    g.message -e "East-West and North-South region resolution must be the same"
    exit 1
else
    res="$nsres"
fi

#### find appropriate tile resolution
fixed_res="
0.000244140625
0.00048828125
0.0009765625
0.001953125
0.00390625
0.0078125
0.015625
0.03125
0.0625
0.125
0.25
"
i=-3
TAKE=9999
TAKE_i=9999
MIN=9999
for val in $fixed_res ; do
   # find nearest resolution:
   #DIFF=`echo "$res $val" | awk '{printf("%.15g", $1 > $2 ? $1 - $2 : $2 - $1)}'`
   # find nearest finer resolution:
   DIFF=`echo "$res $val" | awk '{printf("%.15g", $1 > $2 ? $1 - $2 : 9999)}'`
   NEW_MIN_DIFF=`echo "$MIN $DIFF" | awk '{printf("%d", $1 < $2 ? 0 : 1)}'`
   if [ "$NEW_MIN_DIFF" -eq 1 ] ; then
      MIN="$DIFF"
      TAKE="$val"
      TAKE_i="$i"
   fi
   i=`expr $i + 1`
done
tile_res=`echo "$TAKE_i" | awk '{printf("%.15g", 2^$1)}'`
g.message -d message="min_diff=$MIN  [2^$TAKE_i = $tile_res  ($TAKE * 512)]"



#### adjust region to snap to grid
# setup internal region
g.region save="tmp_tiled_wms.$$"
WIND_OVERRIDE="tmp_tiled_wms.$$"
export WIND_OVERRIDE


g.region res="$TAKE" -a
eval `g.region -g`

# snap lat,long to upper-left corner of nearest tile grid node
# Round lat to nearest grid node
#lat = 90.0   - round( (90.0 - lat) / $res) * $res;
#lon = -180.0 + floor( (180.0 + lon) / $res) * $res;

# diff is always positive here, so int() acts like floor().
n=`echo "$n $tile_res" | \
   awk '{ printf("%.15g", 90.0 - int((90.0 - $1) / $2) * $2) }'`
s=`echo "$s $tile_res" | awk '
 function ceil(x)
 {
   return (x == int(x)) ? x : int(x)+1
 }
 {
   printf("%.15g", 90.0 - ceil((90.0 - $1) / $2) * $2)
 }'`

e=`echo "$e $tile_res" | \
   awk '{ printf("%.15g", -180.0 + int((180.0 + $1) / $2) * $2) }'`
w=`echo "$w $tile_res" | awk '
 function ceil(x)
 {
   return (x == int(x)) ? x : int(x)+1
 }
 {
   printf("%.15g", -180.0 + ceil((180.0 + $1) / $2) * $2)
 }'`

#needed?
#g.region n=$n s=$s e=$e w=$w

NUM_TILES_x=`echo "$e $w $tile_res" | awk '{ printf("%d", ($1 - $2) / $3) }'`
NUM_TILES_y=`echo "$n $s $tile_res" | awk '{ printf("%d", ($1 - $2) / $3) }'`

TOTAL_TILES=`expr $NUM_TILES_x \* $NUM_TILES_y`

if [ "$TOTAL_TILES" -gt 100 ] ; then
    g.message -w "You've told it to download $TOTAL_TILES tiles from NASA's server. Are you sure you want to do that?"
    read result
    case $result in
       y | yes | Y | Yes | YES)
	  ;;
       *)
	  g.message -i "Aborting."
	  exit 1
	  ;;
     esac
fi


#######################################################
# start of todo code dump


LAYER="global_mosaic_base"
STYLE="visual"

BASE_URL="http://onearth.jpl.nasa.gov/wms.cgi"
BASE_REQUEST="request=GetMap&layers=$LAYER&srs=EPSG:4326&width=512&height=512"
BASE_META="format=image/jpeg&version=1.1.1&styles=$STYLE"


# try a few at once, but don't get abusive
MAX_DL_JOBS=4

for i in `seq $NUM_TILES_x` ; do
   i_str=`echo "$i" | awk '{printf("%04d", $1)}'`
   for j in `seq $NUM_TILES_y` ; do
      j_str=`echo "$j" | awk '{printf("%04d", $1)}'`
      minx=$(echo "$w $i $tile_res" | awk '{printf("%.9f", $1 + (($2 - 1) * $3))}')
      maxx=$(echo "$w $i $tile_res" | awk '{printf("%.9f", $1 + ($2 * $3))}')
      maxy=$(echo "$n $j $tile_res" | awk '{printf("%.9f", $1 - (($2 - 1) * $3))}')
      miny=$(echo "$n $j $tile_res" | awk '{printf("%.9f", $1 - ($2 * $3))}')

      BBOX_TILE="$minx,$miny,$maxx,$maxy"
      BBOX="bbox=$BBOX_TILE"
      g.message -d message="  $BBOX"

      URL="$BASE_URL?$BASE_REQUEST&$BBOX&$BASE_META"

      CMD="wget -nv \"$URL\" -O twms_${i_str}_${j_str}.jpg"

      MODULUS=`echo "$j $MAX_DL_JOBS" | awk '{print $1 % $2}'`
      g.message -d message="modulus=$MODULUS"
      if [ "$MODULUS" = "0" ] || [ "$j" = "$NUM_TILES_y" ] ; then
	  # stall to let the background jobs finish
	 g.message -v "Downloading tile [$i,$j] of [${NUM_TILES_x}x$NUM_TILES_y]."
	 eval $CMD
	 sleep 0.08
	 wait
      else
	 g.message -v "Downloading tile [$i,$j] of [${NUM_TILES_x}x$NUM_TILES_y],"
	 eval $CMD &
	 sleep 0.08
      fi
      wait
   done
done


#### some checks before going on
if [ `ls -1 twms_*.jpg | wc -l` -lt "$TOTAL_TILES" ] ; then
    g.message -e "Tile(s) appear to be missing."
    exit 1
fi

for file in twms_*.jpg ; do
    if [ ! -s "$file" ] ; then
	echo "ERROR: <$file> appears to be empty." 1>&2
	exit 1
    fi
    if [ `file "$file" | grep -c JPEG` -eq 0 ] ; then
	echo "ERROR: <$file> appears to be bogus." 1>&2
	if [ `file "$file" | grep -c XML` -eq 1 ] && [ "$GRASS_VERBOSE" = "true" ] ; then
	   cat "$file"
	fi
	exit 1
    fi
done

g.message -v "Converting to pnm ..." 1>&2
for file in twms_*.jpg ; do
    jpegtopnm "$file" > `basename "$file" .jpg`.pnm
done



g.message -v "Patching ..." 1>&2

for j in `seq $NUM_TILES_y` ; do
   j_str=`echo "$j" | awk '{printf("%04d", $1)}'`
   tilefiles=`ls twms_*_${j_str}.pnm`
   #echo $tilefiles
   pnmcat -lr $tilefiles > "row_${j_str}.pnm"
done

pnmcat -tb row_*.pnm | pnmtojpeg --quality=75 > mosaic_$$.jpg

rm -f twms_*.pnm twms_*.jpg row*.pnm

gdal_translate mosaic_$$.jpg mosaic_$$.tif \
  -a_srs EPSG:4326 -a_ullr $w $n $e $s  
  #-co COMPRESS=DEFLATE

r.in.gdal in="mosaic_$$.tif" out="tmp_rio_$$" \
   title="NASA OnEarth WMS $LAYER ($STYLE)"

for COLOR in red green blue ; do
   r.support "tmp_rio_$$.$COLOR" \
      history="Data downloaded from NASA's OnEarth WMS server with r.in.onearth"
done

# free up the disk space ASAP
\rm "mosaic_$$.tif"



# end of todo code dump
#######################################################






#Some functions
#Get the data from the NASA server
GetData()
{
   IMPORT=0 #default
   local STRING="request=GetMap&layers=$LAYER&srs=$SRC&width=$WIDTH&height=$HEIGHT&bbox=$w,$s,$e,$n&format=$FORMAT&version=1.1.0&styles=$STYLE$TIME"
   #echo $STRING
   #Create thefilename
   IMAGEFILE="$TMPDIR/Image_${LAYER}_${STYLE}_${HEIGHT}_$WIDTH"
   g.message -v "**** DOWNLOAD DATA ****"
   g.message -v "Requesting Data from $NASASERVER"

   #download the File from the Server
   wget $WGET_OPTIONS --post-data="$STRING" "$NASASERVER" -O "$IMAGEFILE" 

   if [ $? -ne 0 ] ; then
     g.message -e "wget was not able to download the data"
     IMPORT=1
     return 1
   fi

   if [ -f "$IMAGEFILE" ] ; then 
     IMPORT=0
   else
     g.message -e "wget was not able to download the data"
     IMPORT=1
     return 1
   fi
return 0
}


#warp the data to the current grass locationa via gdalwarp
WarpData()
{
    if [ "$USE_GDALWARP" = "true" ] ; then 
	g.message -v "**** CONVERT DATA  ****"
	#create the new imagename
	IMAGEFILE_GDALWARP="$TMPDIR/Image_${LAYER}_${STYLE}_${HEIGHT}_${WIDTH}_gdalwarp"

	   #convert the data to the current location, create Erdas Imagine Images (HFA)
	gdalwarp -s_srs "$SRC" -t_srs "`g.proj -wf`" -of HFA \
	    "$IMAGEFILE" "$IMAGEFILE_GDALWARP"
	if [ $? -ne 0 ] ; then
	  g.message -i '!-------- CAN NOT CONVERT DATA --------!'
	  g.message -i '!------------ WILL BREAK --------------!'
	  exitprocedure
	fi
	g.message -v "**** DATA CONVERTED ****"
	#remove the old image and convert the name
	rm -f "$IMAGEFILE"
	IMAGEFILE="$IMAGEFILE_GDALWARP"
	return 0
    fi
    return 1
}


#Import the Data with r.in.gdal
ImportData()
{
   if [ "$IMPORT" -eq 0 ] ; then 
	#Check if Tiff file
	FILETYPE=`file  "$IMAGEFILE" | cut --fields=2 --delimiter=:`
	echo "$FILETYPE" | grep TIFF > /dev/null
	if [ $? -ne 0 ] ; then
	    g.message -i "Downloaded file is not a GeoTiff file, but will try to import"
	fi
	g.message -v "**** CHECK DATA ****"
	gdalinfo "$IMAGEFILE" | grep "GDALOpen failed" > /dev/null
	local ReturnValueGdalBug=$?
	
	gdalinfo "$IMAGEFILE"
	local ReturnValueGdal=$?

	if [ "$ReturnValueGdal" -eq 0 ] && [ "$ReturnValueGdalBug" -ne 0 ] ; then
	    g.message -v "**** DATA CHECK OK ****"
	    #Copy or import
	    if [ "$GIS_FLAG_F" -eq 1 ] ; then
		#Copy the data to the outputfile
		g.message -v "Creating output file $GIS_OPT_FILE$TYPE$STYLE$FILE_EXTENT"
		cp "$IMAGEFILE" "$GIS_OPT_FILE$TYPE$STYLE$FILE_EXTENT"
	    else
		#Warp the data!
		WarpData
		g.message -v "**** IMPORT DATA ****"
		r.in.gdal -o input="$IMAGEFILE" \
		     output="$GIS_OPT_OUTPUT${TYPE}_$STYLE"
	    fi
	else
	    echo '!-------------------BREAK---------------------!'
	    echo "Downloaded file is not supported by gdal, or cannot be imported"
	    if [ $ReturnValueGdalBug -eq 0 ] ; then
		echo "There was a problem while downloading the file, maybe you should try it again."
	    fi
	    g.message -v "File of Type: $FILETYPE"
	    #If the File is XML, then cat the contents to stdout
	    echo "$FILETYPE" | grep XML > /dev/null
	    if [ $? -eq 0 ] ; then
		g.message " "
		g.message "Message from Server $NASASERVER"
		echo " "
		echo '!------------BEGIN-ERROR-MESSGAE--------------!'
		cat "$IMAGEFILE"
		echo '!-------------END-ERROR-MESSGAE---------------!'
	    fi
	fi
	rm -rf "$IMAGEFILE"
    fi
    return 0
}


# what to do in case of user break:
exitprocedure()
{
    g.message 'User break!'
    rm -rf "$TMPDIR"
    unset WIND_OVERRIDE
    g.remove region="tmp_tiled_wms.$$" --quiet
    exit 1
}
trap "exitprocedure" 2 3 15


#At least one flag should be set
if [ $GIS_FLAG_L -eq 0  -a  $GIS_FLAG_S -eq 0  -a  $GIS_FLAG_B -eq 0 ] \
   && [ $GIS_FLAG_T -eq 0  -a  $GIS_FLAG_A -eq 0 ] ; then
    g.message -e "Select a flag to specify map type"
    exit 1
fi

#Check if a file or a map should be created
if [ "$GIS_FLAG_F" -eq 1 ] ; then
    if [ -z "$GIS_OPT_FILE"] ; then
	  g.message -e "Please specify the output filename"
	exit 1
    fi
fi

#Some mapset informations 
eval `g.gisenv`
: ${GISBASE?} ${GISDBASE?} ${LOCATION_NAME?} ${MAPSET?}
LOCATION="$GISDBASE/$LOCATION_NAME/$MAPSET"
PERM="$GISDBASE/$LOCATION_NAME/PERMANENT"

#wget has many options
WGET_OPTIONS="$GIS_OPT_WGETOPT"

#Get the region data 
eval `g.region -g`
WIDTH="$cols"
HEIGHT="$rows"
eval `g.region -gb`
#Now get the LatLong Boundingbox
grep -i 'proj: ll' $PERM/PROJ_INFO > /dev/null
if [ $? -ne 0 ] && [ "$USE_GDALWARP" = "true" ] ; then
    n="$ll_n"
    s="$ll_s"
    e="$ll_e"
    w="$ll_w"
    g.message -v "LatLong wgs84 bounding box = N $n S $s W $w E $e"
else
    #We have LatLong projection, no warp is needed!
    USE_GDALWARP="false"
    #There is a bug in nasa WMS service, it provides images which are lager then
    #the world :(, we have to crop the images
    if [ "$n" = "90" -a "$s" = "-90" ] && \
       [ "$w" = "-180" -a "$e" = "180" ] ; then

	# check if we have bc
	if [ ! -x "`which bc`" ] ; then
	    g.message -e "bc required, please install first"
	    exit 1
	fi
	#We request a smaller image from the wms server
	n=`echo "$n - 0.001" | bc`
	s=`echo "$s + 0.001" | bc`
	e=`echo "$e - 0.001" | bc`
	w=`echo "$w + 0.001" | bc`
    fi
fi

#Break If we have no warp and no LatLong
grep -i 'proj: ll' "$PERM/PROJ_INFO" > /dev/null
if [ $? -ne 0 ] && [ "$USE_GDALWARP" = "false" ] ; then
    g.message -e "NASA OnEarth data are in Latitude/Longitude. The \
		  current location projection differs and you don't \
		  have gdalwarp! STOP."
    exit 1
fi


#make a temporary directory
TMPDIR="`g.tempfile pid=$$`"
if [ $? -ne 0 ] || [ -z "$TMPDIR" ] ; then
    g.message -e "Unable to create temporary files"
    exit 1
fi
rm -f "$TMPDIR"
mkdir "$TMPDIR"

#Get the Data and import them
#import every choice that can be made

if [ $GIS_FLAG_L -eq 1 ] ; then
    LAYER="$GLOBAL_MOSAIC_LAYER"
    STYLE="$GIS_OPT_TMBAND"
    TYPE="LandsatTM"
    g.message -v "Will download and import $TYPE Data with band $STYLE"
    GetData
    ImportData
fi


if [ $GIS_FLAG_S -eq 1 ] ; then
    LAYER="$SRTM_MAG_LAYER"
    STYLE="$GIS_OPT_SRTMBAND"
    TYPE="SRTM"
    g.message -v "Will download and import $TYPE Data with band $STYLE"
    GetData
    ImportData
fi

if [ $GIS_FLAG_B -eq 1 ] ; then
    LAYER="$BMNG_LAYER"
    STYLE="$GIS_OPT_MONTH"
    TYPE="BMNG"
    g.message -v "Will download and import $TYPE Data of month $STYLE"
    GetData
    ImportData
fi

if [ $GIS_FLAG_T -eq 1 ] ; then
    LAYER="$DAILY_TERRA_LAYER"
    TIME="&time=$GIS_OPT_TIME"
    STYLE=""
    TYPE="Daily_Terra"
    g.message -v "Will download and import $TYPE Data"
    GetData
    ImportData
fi

if [ $GIS_FLAG_A -eq 1 ] ; then
    LAYER="$DAILY_AQUA_LAYER"
    TIME="&time=$GIS_OPT_TIME"
    STYLE=""
    TYPE="Daily_Aqua"
    g.message -v "Will download and import $TYPE Data"
    GetData
    ImportData
fi

#remove the temp dir
rm -rf "$TMPDIR"

unset WIND_OVERRIDE
g.remove region="tmp_tiled_wms.$$" --quiet

g.message -v "Finished"

exit 0
