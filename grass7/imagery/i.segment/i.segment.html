<h2>DESCRIPTION</h2>
Image segmentation is the process of grouping similar pixels into unique segments.  Boundary and region based algorithms are described in the literature, currently a region growing and merging algorithm is implemented.  Each object found during the segmentation process is given a unique ID and is a collection of contiguous pixels meeting some criteria.  (Note the contrast with image classification, where continuity and spatial characteristics are not important, but rather only the spectral simularity.)  The results can be useful on their own, or used as a preprocessing step for image classification.  The segmentation preprocessing step can reduce noise and speed up the classification.

<H2>NOTES</h2>

<h3>Region Growing and Merging</h3>
This segmentation algorithm sequentially examines all current segments in the map.  The similarity between the current segment and each of its neighbors is calculated according to the given distance formula.  Segments will be merged if they meet a number of criteria, including: 1.  The pair is mutually most similar to each other (the similarity distance will be smaller then all other neighbors), and 2. The similarity must be lower then the input threshold.  All segments are checked once per pass.  The process is repeated until no merges are made during a complete pass.

<h3>Threshold</h3>
During normal processing, merges are only allowed when the similarity between two segments is lower then the calculated threshold value.  During the final pass, however, if a minimum segment size of 2 or larger is given with the <em>minsize</em> parameter, segments with a smaller pixel count will be merged with their most similar neighbor even if the similarity is greater then the threshold.
<p>
Unless the <em>-w</em> flag for weighted data is used, the threshold should be between 0 and 1.0.
</p><p>
The threshold will be multiplied by the number of rasters included in the image group.  This will allow the same threshold to achieve similar segmentation results when the number of rasters in the image group varies.
</p>
<h3>Seeds</h3>
The seeds map can be used to provide either seed pixels (random or selected points from which to start the segmentation process) or seed segments (results of previous segmentations or classifications).  The different approaches are automatically detected by the program: any pixels that have identical seed values and are contiguous will be lumped into a single segment ID.
<p>
It is expected that the <em>minsize</em> will be set to 1 if a seed map is used, but the program will allow other values to be used.  If both options are used, the final iteration that ignores the threshold also will ignore the seed map and force merges for all pixels (not just segments that have grown/merged from the seeds).
</p>
<h3>Maximum number of starting segments</h3>
For the region growing algorithm without starting seeds, each pixel is sequentially numbered.  The current limit with CELL storage is 2 billion starting segment ID's.  If the initial map has a larger number of non-null pixels, there are two workarounds:
<p>
1.  Use starting seed pixels.  (Maximum 2 billion pixels can be labeled with positive integers.)
</p><p>
2.  Use starting seed segments.  (By initial classification or other methods.)
</p>
<h3>Boundary Constraints</h3>
Boundary constraints limit the adjacency of pixels and segments.  Each unique value present in the <em>bounds</em> raster are considered as a MASK.  Thus no segments in the final segmentated map will cross a boundary, even if their spectral data is very similar.

<h3>Minimum Segment Size</h3>
To reduce the salt and pepper affect, a <em>minsize</em> greater than 1 will add one additional pass to the processing.  During the final pass, the threshold is ignored for any segments smaller then the set size, thus forcing very small segments to merge with their most similar neighbor.

<H2>EXAMPLES</h2>
This example uses the ortho photograph included in the NC Sample Dataset.  Set up an imagery group:<br>
<blockquote>i.group group=ortho_group input=ortho_2001_t792_1m@PERMANENT</blockquote>

<p>Because the segmentation process is computationally expensive, start with a small processing area to confirm if the segmentation results meet your requirements.  Some manual adjustment of the threshold may be required. <br>

<blockquote>g.region rast=ortho_2001_t792_1m@PERMANENT n=220400 s=220200 e=639000 w=638800</blockquote>
<p></p>
Try out a first threshold and check the results.<br>
<blockquote>i.segment -w -l group=ortho_group output=ortho_segs threshold=4 method=region_growing</blockquote>
<p></p>
From a visual inspection, it seems this results in oversegmentation.  Increasing the threshold: <br>
<blockquote>i.segment -w -l --overwrite group=ortho_group output=ortho_segs threshold=10 method=region_growing</blockquote>
<p></p>
This looks better.  There is some noise in the image, lets next force all segments smaller then 5 pixels to be merged into their most similar neighbor (even if they are less similar then required by our threshold):<br>
<blockquote>i.segment -w -l --overwrite group=ortho_group output=ortho_segs threshold=10 method=region_growing minsize=5</blockquote>
<p></p>
Each of these segmentation steps took less then 1 minute on a decent machine.  Now that we are satisfied with the settings, we'll process the entire image:
<blockquote>g.region rast=ortho_2001_t792_1m@PERMANENT<br>
i.segment -w -l --overwrite group=ortho_group output=ortho_segs threshold=10 method=region_growing minsize=5 endt=5000</blockquote>
<p></p>
Processing the entire ortho image (over 9 million cells) took about !currently running, will insert time in the morning! .

<h2>TODO</h2>
<h3>Functionality</h3>
<ul>
<li>Add shape characteristics (smoothness, compactness) to the similarity measurement.  This will add two input parameters (weight of radiometric to shape, and weight of compactness to smoothness.)</li>
<li>Malahanobis distance for the similarity calculation.</li>
<li>Estimating the threshold value. (1 to 5% of the max difference gave me subjectively good results.)</li>
</ul>
<h3>Use of Segmentation Results</h3>
<ul>
<li>Improve the optional output from this module, or better yet, add a module for i.segment.metrics.</li>
<li>Providing updates to i.maxlik to ensure the segmentation output can be used as input for the existing classification functionality.</li>
<li>Integration/workflow for r.fuzzy.</li>
</ul>
<h3>Speed</h3>
<ul>
<li>See create_isegs.c</li>
</ul>
<h3>Memory</h3>
<ul>
<li>User input for how much RAM can be used.</li>
<li>Check input map type(s), currently storing in DCELL sized SEG file, could reduce this dynamically depending on input map time. (Could only reduce to FCELL, since will be storing mean we can't use CELL. Might not be worth the added code complexity.)</li>
</ul>
<h2>BUGS</h2>
If the seeds map is used to give starting seed segments, the segments are renumbered starting from 1.  There is a chance a segment could be renumbered to a seed value that has not yet been processed.  If they happen to be adjacent, they would be merged.  (Possible fixes: a.  use a processing flag to make sure the pixels hasn't been previously used, or b. use negative segment ID's as a placeholder and negate all values after the seed map has been processed.)
<H2>REFERENCES</h2>
This project was first developed during GSoC 2012.  Project documentation, Image Segmentation references, and other information is at the <a href="http://grass.osgeo.org/wiki/GRASS_GSoC_2012_Image_Segmentation">project wiki</a>.
<p>
Information about <a href="http://grass.osgeo.org/wiki/Image_classification">classification in GRASS</a> is at available on the wiki.
</p>
<h2>SEE ALSO</h2>
<em>
<a href="i.group.html">i.group</a>, 
<a href="i.maxlik.html">i.maxlik</a>, 
<a href="r.fuzzy">r.fuzzy</a>, 
<a href="i.smap.html">i.smap</a>, 
<a href="r.seg.html">r.seg</a> (Addon)
</em>

<h2>AUTHORS</h2>
Eric Momsen - North Dakota State University
