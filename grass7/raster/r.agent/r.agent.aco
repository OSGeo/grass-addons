#!/usr/bin/env python
"""
MODULE:       r.agent.aco
AUTHOR(S):    michael lustenberger inofix.ch
PURPOSE:      r.agent.aco is used to organize ant-like agents in a raster
              based playground. As decribed by the Ant Colony Optimization
              algorithm, the ants wander around looking for attractors,
              marking their paths if they find any.
COPYRIGHT:    (C) 2011 by Michael Lustenberger and the GRASS Development Team

              This program is free software under the GNU General Public
              License (>=v2). Read the file COPYING that comes with GRASS
              for details.
"""

#%Module
#% description: Agents wander around on the terrain, marking paths to new locations.
#%End
#%option
#% key: outputmap
#% type: string
#% gisprompt: old,cell,raster
#% description: Name of pheromone output map
#% required : yes
#%end
#%option
#% key: inputmap
#% type: string
#% gisprompt: old,cell,raster
#% description: Name of input pheromone raster map (e.g. from prior run)
#% required : no
#%end
#%flag
#% key: p
#% description: Allow overwriting existing pheromone maps
#%end
#%flag
#% key: c
#% description: Overwrite existing cost map (only used with penalty conversion)
#%end
#%option
#% key: costmap
#% type: string
#% gisprompt: old,cell,raster
#% description: Name of penalty resp. cost raster map (note conversion checkbox)
#% required : yes
#%end
#%flag
#% key: a
#% description: Auto-convert cost (slope..) to penalty map (using "tobler", see docu)
#%end
#%option
#% key: sitesmap
#% type: string
#% gisprompt: old,vect,vector
#% description: Name of sites map, vector data with possible points of origin
#% required : yes
#%end
#%option
#% key: rounds
#% type: integer
#% gisprompt: number
#% description: Number of iterations/rounds to run
#% answer: 999
#% options: 0-999999
#% required : yes
#%end
#%option
#% key: outrounds
#% type: integer
#% gisprompt: number
#% description: Produce output after running this number of iterations/rounds
#% options: 0-999999
#% required : no
#%end
#%option
#TODO evaluate..
#% key: targetvisibility
#% type: integer
#% gisprompt: number
#% description: Distance to target from where it might be 'sensed'
#% options: 0-999999
#% required : no
#%end
#%option
#% key: highcostlimit
#% type: integer
#% gisprompt: number
#% description: Penalty values above this point an ant considers as illegal
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option                                                       
#% key: lowcostlimit
#% type: integer
#% gisprompt: number
#% description: Penalty values below this point an ant considers as illegal
#% options: <min integer on system would make sense>-0
#% required : no
#%end
#%option
#% key: maxpheromone
#% type: integer
#% gisprompt: number
#% description: Absolute maximum of pheromone intensity a position may have
#% options: <minpheromone>-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: minpheromone
#% type: integer
#% gisprompt: number
#% description: Absolute minimum of pheromone intensity to leave on playground
#% options: 0-<maxpheromone>
#% required : no
#%end
#%option
#% key: volatilizationtime
#% type: integer
#% gisprompt: number
#% description: Half-life for pheromone to volatize (e.g. =rounds)
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: stepintensity
#% type: integer
#% gisprompt: number
#% description: Pheromone intensity to leave on each step
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: pathintensity
#% type: integer
#% gisprompt: number
#% description: Pheromone intensity to leave on found paths
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: maxants
#% type: integer
#% gisprompt: number
#% description: Maximum amount of ants that may live concurrently (x*y)
#% options: 0-<the bigger the playground, the more space they have>
#% required : no
#%end
#%option
#% key: antslife
#% type: integer
#% gisprompt: number
#% description: Time to live for an ant (e.g. four times points distance)
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: decisionalgorithm
#% type: string
#% gisprompt: algorithm
#% description: Algorithm used for walking step
#% answer: standard
#% options: standard,random,test
#% required : yes
#%end
#%option
#% key: validposition
#% type: string
#% gisprompt: algorithm
#% description: Algorithm used for finding and remembering paths
#% answer: avoidorforgetloop
#% options: specials,avoidloop,forgetloop,avoidorforgetloop
#% required : yes
#%end
#%option
#% key: agentfreedom
#% type: integer
#% gisprompt: number
#% description: Number of possible directions the ant can take (4 or 8)
#% options: 4,8
#% required : no
#%end
#%option
#% key: pheromoneweight
#% type: integer
#% gisprompt: number
#% description: How is the pheromone value (P) weighted when walking (p*P:r*R:c*C)
#% answer: 1
#% options: 0-999
#% required : yes
#%end
#%option
#% key: randomnessweight
#% type: integer
#% gisprompt: number
#% description: How is the random value (R) weighted when walking (p*P:r*R:c*C)
#% answer: 1
#% options: 0-999
#% required : yes
#%end
#%option
#% key: costweight
#% type: integer
#% gisprompt: number
#% description: How is the penalty value (C) weighted when walking (p*P:r*R:c*C)
#% answer: 0
#% options: 0-999
#% required : yes
#%end

from sys  import exit, maxsize
from math import sqrt
from math import exp
from random import randint

from libagent import error, grassland, anthill

try:
    from grass.script import core as grass
except ImportError:
    raise error.EnvError("r.agent.aco:", "Please run inside GRASS.")

world = anthill.Anthill(grassland.Grassland())

def setmaps(site, cost, wastecosts, inphero, outphero, wastephero):
    """
    Set the user maps in place
    """
    if site:
        if -1 == site.find('@'):
            site = site + '@' + grass.gisenv()['MAPSET']
        # set sitemap and site list
        world.sites = world.playground.parsevectorlayer(anthill.Anthill.SITE,
                                                        site, True)
        if not world.sites:
            raise error.DataError("r.agent.aco:",
                                    "There were no sites in" + site)
    else:
        raise error.DataError("r.agent.aco:", "The site map is mandatory.")
    if cost:
        if -1 == cost.find('@'):
            cost = cost + '@' + grass.gisenv()['MAPSET']
        # set cost/penalty layer
        world.playground.setgrasslayer(anthill.Anthill.COST, cost, True)
        world.overwritepenalty = wastecosts
    else:
        raise error.DataError("r.agent.aco:", "The cost map is mandatory.")
    if outphero:
        if -1 == outphero.find('@'):
            outphero = outphero + '@' + grass.gisenv()['MAPSET']
    else:
        raise error.DataError("r.agent.aco:", "The output map is mandatory.")
    if inphero == outphero:
        if not wastephero:
            raise error.DataError("aco:", "May not overwrite the output map.")
    if inphero:
        if -1 == inphero.find('@'):
            inphero = inphero + '@' + grass.gisenv()['MAPSET']
        world.playground.setgrasslayer(anthill.Anthill.RESULT, inphero, True)
    world.playground.grassmapnames[anthill.Anthill.RESULT] = outphero
    world.overwritepheormone = wastephero

def letantsdance(rounds, outrounds):
    """
    Organize the agents and the pheromone on the playground.
    """
    if 0 < outrounds < rounds:
        # calculate when to write output
        mainloops = rounds / outrounds
        nextwrite = outrounds
    else:
        # produce output only at the end
        mainloops = 1
        nextwrite = rounds
    while mainloops > 0:
#        grass.info(mainloops)
        # loop and write out the contents at the end
        world.letantsdance(nextwrite)
        # export the value maps
        world.playground.writelayer(anthill.Anthill.RESULT,
                                        world.overwritepheormone)
#        print "nrofpaths:", world.nrop
        # count down outer
        mainloops -= 1
#    print "nrofrounds", nrofrounds

def main():

    try:
        setmaps(options['sitesmap'],
            options['costmap'], flags['c'],
            options['inputmap'], options['outputmap'], flags['p'])

#        world.playground.setboundsfromlayer("costs")

        if options['maxpheromone']:
            world.maxpheromone = int(options['maxpheromone'])
        if options['minpheromone']:
            world.minpheromone = int(options['minpheromone'])
        if options['volatilizationtime']:
            world.volatilizationtime = int(options['volatilizationtime'])
        if options['stepintensity']:
            world.stepintensity = int(options['stepintensity'])
        if options['pathintensity']:
            world.pathintensity = int(options['pathintensity'])
        if options['maxants']:
            world.maxants = int(options['maxants'])
        if options['antslife']:
            world.antslife = int(options['antslife'])
#        if options['decisionalgorithm']:
#            world.decisionbase = str(options['decisionalgorithm'])
#        if options['validposition']:
#            world.validposition = str(options['validposition'])
#        if options['agentfreedom']:
#            world.globalfreedom = int(options['agentfreedom'])
        if options['pheromoneweight']:
            world.pheroweight = int(options['pheromoneweight'])
        if options['randomnessweight']:
            world.randomweight = int(options['randomnessweight'])
        if options['costweight']:
            world.costweight = int(options['costweight'])
        #if arglist[0] == "stability":
            #TODO ask silvia..


#        world.checkvalues()
        if not options['outrounds']:
            options['outrounds'] = 0
    except error.DataError:
        grass.fatal("Failed to parse args..")
        sys.exit(1)
    letantsdance(int(options['rounds']), int(options['outrounds']))
    grass.message("FINISH")

if __name__ == "__main__":
    options, flags = grass.parser()
    main()

