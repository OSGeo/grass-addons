#!/usr/bin/env python
"""
MODULE:       r.agent.aco
AUTHOR(S):    michael lustenberger inofix.ch
PURPOSE:      r.agent.aco is used to organize ant-like agents in a raster
              based playground. As decribed by the Ant Colony Optimization
              algorithm, the ants wander around looking for attractors,
              marking their paths if they find any.
COPYRIGHT:    (C) 2011 by Michael Lustenberger and the GRASS Development Team

              This program is free software under the GNU General Public
              License (>=v2). Read the file COPYING that comes with GRASS
              for details.
"""

#%Module
#% description: Creates a special kind of world, that follows the rules of ACO - with ant-like agents in it.
#%End
#%option
#% key: outputmap
#% type: string
#% gisprompt: old,cell,raster
#% description: Name of pheromone output map
#% required : yes
#%end
#%option
#% key: inputmap
#% type: string
#% gisprompt: old,cell,raster
#% description: Name of input pheromone raster map (e.g. from prior run)
#% required : no
#%end
#%flag
#% key: overwrite
#% description: Allow overwriting existing pheromone maps (e.g. if in == out)
#%end
#%flag
#% key: overwritecosts
#% description: Overwrite existing cost map (only used with penalty conversion)
#%end
#%option
#% key: costmap
#% type: string
#% gisprompt: old,cell,raster
#% description: Name of penalty resp. cost raster map (note conversion checkbox)
#% required : yes
#%end
#%flag
#% key: convert
#% description: Convert cost (slope..) to penalty map (using "tobler", see docu)
#%end
#%option
#% key: sitesmap
#% type: string
#% gisprompt: vector
#% description: Name of sites map, vector data with possible points of origin
#% required : yes
#%end
#%option
#% key: rounds
#% type: integer
#% gisprompt: number
#% description: Number of iterations/rounds to run
#% answer: 999
#% options: 0-999999
#% required : yes
#%end
#%option
#% key: outrounds
#% type: integer
#% gisprompt: number
#% description: Produce output after running this number of iterations/rounds
#% options: 0-999999
#% required : no
#%end
#%option
#% key: highcostlimit
#% type: integer
#% gisprompt: number
#% description: Penalty values above this point an ant considers as illegal
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option                                                       
#% key: lowcostlimit
#% type: integer
#% gisprompt: number
#% description: Penalty values below this point an ant considers as illegal
#% options: <min integer on system would make sense>-0
#% required : no
#%end
#%option
#% key: maxpheromone
#% type: integer
#% gisprompt: number
#% description: Absolute maximum of pheromone intensity a position may have
#% options: <minpheromone>-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: minpheromone
#% type: integer
#% gisprompt: number
#% description: Absolute minimum of pheromone intensity to leave on playground
#% options: 0-<maxpheromone>
#% required : no
#%end
#%option
#% key: volatilizationtime
#% type: integer
#% gisprompt: number
#% description: Half-life for pheromone to volatize (e.g. =rounds)
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: stepintensity
#% type: integer
#% gisprompt: number
#% description: Pheromone intensity to leave on each step
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: pathintensity
#% type: integer
#% gisprompt: number
#% description: Pheromone intensity to leave on found paths
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: maxants
#% type: integer
#% gisprompt: number
#% description: Maximum amount of ants that may live concurrently (x*y)
#% options: 0-<the bigger the playground, the more space they have>
#% required : no
#%end
#%option
#% key: antslife
#% type: integer
#% gisprompt: number
#% description: Time to live for an ant (e.g. four times points distance)
#% options: 0-<max integer on system would make sense>
#% required : no
#%end
#%option
#% key: decisionalgorithm
#% type: string
#% gisprompt: algorithm
#% description: Algorithm used for walking step
#% answer: standard
#% options: standard,random,test
#% required : yes
#%end
#%option
#% key: validposition
#% type: string
#% gisprompt: algorithm
#% description: Algorithm used for finding and remembering paths
#% answer: avoidorforgetloop
#% options: specials,avoidloop,forgetloop,avoidorforgetloop
#% required : yes
#%end
#%option
#% key: agentfreedom
#% type: integer
#% gisprompt: number
#% description: Number of possible directions the ant can take (4 or 8)
#% options: 4,8
#% required : no
#%end
#%option
#% key: pheromoneweight
#% type: integer
#% gisprompt: number
#% description: How is the pheromone value (P) weighted when walking (p*P:r*R:c*C)
#% answer: 1
#% options: 0-999
#% required : yes
#%end
#%option
#% key: randomnessweight
#% type: integer
#% gisprompt: number
#% description: How is the random value (R) weighted when walking (p*P:r*R:c*C)
#% answer: 1
#% options: 0-999
#% required : yes
#%end
#%option
#% key: costweight
#% type: integer
#% gisprompt: number
#% description: How is the penalty value (C) weighted when walking (p*P:r*R:c*C)
#% answer: 0
#% options: 0-999
#% required : yes
#%end

import sys
from libagent import error, aco

try:
    from grass.script import core as grass
except ImportError:
    raise error.EnvError("r.agent.aco:", "Please run inside GRASS.")

def main():
    world = aco.ACO()

    layer = world.importlayer("costs", "raster", options['penaltymap'])
    world.costsurface = layer.raster
    world.playground.setboundsfromlayer("costs")

    if options['inputmap']:
        layer = world.importlayer("phero", "raster", options['inputmap'])
        world.outfilename = options['outputmap']
    else:
        layer = world.createlayer("phero", "raster", None, options['outputmap'])
        world.pherovapour = layer.raster

    layer = world.importlayer("holes", "vector", options['sitesmap'])
    world.holes = layer.objects

    world.rounds = int(options['rounds'])
    if options['outrounds']:
        world.outrounds = int(options['outrounds'])
    if options['maxpheromone']:
        world.maxpheromone = int(options['maxpheromone'])
    if options['minpheromone']:
        world.minpheromone = int(options['minpheromone'])
    if options['volatilizationtime']:
        world.volatilizationtime = int(options['volatilizationtime'])
    if options['stepintensity']:
        world.stepintensity = int(options['stepintensity'])
    if options['pathintensity']:
        world.pathintensity = int(options['pathintensity'])
    if options['maxants']:
        world.maxants = int(options['maxants'])
    if options['antslife']:
        world.antslife = int(options['antslife'])
    if options['decisionalgorithm']:
        world.decisionbase = str(options['decisionalgorithm'])
    if options['validposition']:
        world.validposition = str(options['validposition'])
    if options['agentfreedom']:
        world.globalfreedom = int(options['agentfreedom'])
    if options['pheromoneweight']:
        world.pheroweight = int(options['pheromoneweight'])
    if options['randomnessweight']:
        world.randomweight = int(options['randomnessweight'])
    if options['costweight']:
        world.costweight = int(options['costweight'])
    #if arglist[0] == "stability":
        #TODO ask silvia..
    try:
        world.checkvalues()
        world.letantsdance()
        grass.message("FINISH")
    except error.DataError:
        grass.fatal_error("Failed to parse args..")
        sys.exit(1)

if __name__ == "__main__":
    options, flags = grass.parser()
    main()

