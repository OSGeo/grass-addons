#!/bin/sh
# 
#set -x
########################################################################
# 
# MODULE:       r.mess
# AUTHOR(S):    Paulo van Breugel <p.vanbreugel AT gmail.com>
# PURPOSE:      Calculate the multivariate environmental similarity 
#               surface (MESS) as proposed by Elith et al., 2010, 
#               Methods in Ecology & Evolution, 1(330â€“342). 
#
# NOTES:        This GRASS script should give results very close (but
#               due to rounding differences probably not exactly the 
#               same) to those calculated in Maxent. If you want to
#               compare, make sure to use the same points as used in
#               Maxent to calculate the MESS, which are, by default, 
#               all background points if I understand it correctly. See
#               [fill in url] for a discussion about the assumptions
#               made and the use of the input parameter 'digits'
#
# Disclaimer:   I use it in my work, but I am aware that it needs
#               improvements. Suggestions for improvements are most
#               welcome. In the meantime, use it at your own risk
#   
# COPYRIGHT: (C) 2014 Paulo van Breugel
#            http://ecodiv.org
#            http://pvanb.wordpress.com/
# 
#            This program is free software under the GNU General Public 
#            License (>=v2). Read the file COPYING that comes with GRASS 
#            for details. 
# 
########################################################################
#
#%Module 
#% description: Computes multivariate environmental similarity surface
#%End 

#%option
#% key: ref_rast
#% type: string
#% gisprompt: old,cell,raster
#% description: Reference distribution as raster
#% key_desc: name
#% required: no
#% multiple: no
#% guisection: reference distribution
#%end

#%option
#% key: ref_vect
#% type: string
#% gisprompt: old,vector
#% description: Reference distribution as point vector layer
#% key_desc: name
#% required: no
#% multiple: no
#% guisection: reference distribution
#%end

#%option
#% key: env_old
#% type: string
#% gisprompt: old,cell,raster
#% description: Input (predictor) raster map(s) 
#% key_desc: names
#% required: yes
#% multiple: yes
#%end

#%option
#% key: env_new
#% type: string
#% gisprompt: old,cell,raster
#% description: Input (predictor) raster map(s) 
#% key_desc: names
#% required: no
#% multiple: yes
#%end

#%option
#% key: output
#% type: string
#% gisprompt: new,cell,raster
#% description: Root name of the output MESS data layers
#% key_desc: name
#% required: yes
#%end

#%option
#% key: digits
#% type: integer
#% description: Precision of your input layers values
#% key_desc: string
#% answer: 1
#% required: yes
#%end

##%flag  # not implemented yet
##% key: n
##% description: Keep individual environmental similarity layers (IES)
##% guisection: Additional statistics
##%end

#%flag
#% key: m
#% description: Calculate Most dissimilar variable (MoD)
#%end

#%flag
#% key: k
#% description: Calculate mean of IES layers
#%end

#%flag
#% key: l
#% description: Calculate median of IES layers
#%end

#%flag
#% key: n
#% description: Area with negative MESS
#%end


#%option
#% key: liblocs
#% type: string
#% description: Location R libraries
#% key_desc: folder
#% required: no
#%end

## Set easier variable names
OUTMAPS="${GIS_OPT_OUTPUT}"
export INMAPS1="${GIS_OPT_ENV_OLD}"
export INMAPS2="${GIS_OPT_ENV_NEW}"

#=======================================================================
## GRASS team recommandations
#=======================================================================

## Check if in GRASS
if  [ -z "$GISBASE" ] ; then
    echo "You must be in GRASS GIS to run this program." 1>&2
    exit 1
fi

## check for awk
if [ ! -x "$(which awk)" ] ; then
    g.message -e "<awk> required, please install <awk> or <gawk> first"
    exit 1
fi

## check for R
if [ ! -x "$(which R)" ] ; then
    g.message -e "<R> required, please install <R> first"
    exit 1
fi

## To parse the code into interactive menu
if [ "$1" != "@ARGS_PARSED@" ] ; then
    exec g.parser "$0" "$@"
fi

## set environment so that awk works properly in all languages ##
unset LC_ALL
export LC_NUMERIC=C


## what to do in case of user break:
exitprocedure()
{
    echo "User break!"
    cleanup
    exit 1
}

## shell check for user break (signal list: trap -l)
trap "exitprocedure" 2 3 15

#=======================================================================
## Config and general procedures
#=======================================================================

##fix this path
if [ -z "$PROCESSDIR" ] ; then
    PROCESSDIR="$HOME"
fi

#fix this path
if [ -z "$LOGDIR" ] ; then
    LOGDIR="$HOME"
fi
LOGFILE="$LOGDIR/r.mess.log"

echo "r.mess :" >> "$LOGFILE"

#=======================================================================
## Preparing input variables for use in R script
#=======================================================================

# Create vectors with names output maps [arrOUT]
# Create vector with names input layers without mapset name [arrIN1]
# The 'removeThis' elements are to initiate the vector. How can I avoid this?

arrOUT="${OUTMAPS}_MESS"
arrIN="removeThis2"
counter=0
IFS=,
for nvar in ${INMAPS1} ; do
    export arrOUT="$arrOUT;${OUTMAPS}_`echo $nvar | awk 'BEGIN{FS="@"}{print $1}'`"
    counter=`expr $counter + 1`
    export arrIN="${arrIN};`echo $nvar | awk 'BEGIN{FS="@"}{print $1}'`"
done

if [ -z "$GIS_OPT_REF_VECT" -a -z "$GIS_OPT_REF_RAST" ]; 
then
    g.message -e message='Missing input: map with the reference distribution (point vector layer -or- a raster layer)'
    exit 1
else
    if [ -n "$GIS_OPT_REF_VECT" -a -n "$GIS_OPT_REF_RAST" ]; then
        g.message message='You gave a vector and raster layer as reference distribution layer. !Using the raster layer!'
        export REF_LAY="${GIS_OPT_REF_RAST}"
        export REF_TYPE="R"
    else 
        if [ -n "$GIS_OPT_REF_RAST" ]; then
        export REF_LAY="${GIS_OPT_REF_RAST}"
        export REF_TYPE="R"
        else 
        export REF_LAY="${GIS_OPT_REF_VECT}"
        export REF_TYPE="V"        
       fi
    fi
fi

#=======================================================================
## testing if exising output maps already exist 
## and for missing input maps
#=======================================================================

# test for output raster map [1]
g.findfile element=cell file=${OUTMAPS}_MESS  > /dev/null
    if [ $? -eq 0 ] ; then
        g.message -e 'The output map '${OUTMAPS}'_MESS already exists'
    exit 1
fi

# test for output raster maps [2]
oIFS=$IFS
IFS=,
for nvar in $INMAPS1 ; do
    arrTEST=${OUTMAPS}_`echo $nvar | awk 'BEGIN{FS="@"}{print $1}'`
    g.findfile element=cell file=${arrTEST} > /dev/null
    if [ $? -eq 0 ] ; then 
        g.message -e 'The output map '${arrTEST}' already exists'
    exit 1
    fi
done
IFS=$oIFS
unset arrTEST

# test for missing input raster maps
oIFS=$IFS
IFS=,
for nvar in $INMAPS1 ; do
    tstIN=`echo $nvar | awk 'BEGIN{FS="@"}{print $1}'`
    g.findfile element=cell file=${tstIN} > /dev/null
    if [ $? -gt 0 ] ; then 
        g.message -e 'The map '${tstIN}' is missing'
    exit 1
    fi
done
IFS=$oIFS
unset tstIN

#=======================================================================
## Creating the R script
#=======================================================================

writeScript(){ 
cat > $1 << "EOF"

options(echo = TRUE)

# Install (if not present) and load required packages

tmp.pack <- tempdir()
libLocs <- Sys.getenv("GIS_OPT_LIBLOCS")	# Location R packages
if(libLocs!=""){
	libLocs <- c(.libPaths(), libLocs, tmp.pack)
}else{
	libLocs <- c(.libPaths(), tmp.pack)
}

if (!"XML" %in% installed.packages(lib.loc=libLocs)){
        install.packages("XML", dep=TRUE, repos='http://cran.us.r-project.org', tmp.pack)
        require(XML, lib.loc=libLocs)
}else{require(XML, lib.loc=libLocs)}

if (!"sp" %in% installed.packages(lib.loc=libLocs)){
        install.packages("sp", dep=TRUE, repos='http://cran.us.r-project.org', tmp.pack)
        require(sp, lib.loc=libLocs)
}else{require(sp, lib.loc=libLocs)}

if (!"spgrass6" %in% installed.packages(lib.loc=libLocs)){
        install.packages("spgrass6", dep=TRUE, repos='http://cran.us.r-project.org', tmp.pack)
        require(spgrass6, lib.loc=libLocs)
}else{require(spgrass6, lib.loc=libLocs)}

outputGRASS <- function (x, separator = ",", h = FALSE) 
{
    con <- textConnection(x)
    MyVar <- read.table(con, header = h, sep = separator, comment.char = "")
    close(con)
    return(MyVar)
}

# Check grass version
grassversion <- as.numeric(system("g.version | cut -c7", intern=T))

## Get vector with variables
ipn	<- Sys.getenv("arrIN")  # variable names
ipn	<- unlist(strsplit(ipn,";"))[-1]
ipn <- tolower(ipn)  # avoid problems with vector column names
ipl	<- Sys.getenv("INMAPS1")  # old environmental layers
ipl	<- unlist(strsplit(ipl,","))
ipl2	<- Sys.getenv("INMAPS2")  # new environmental layers
if(ipl2==""){
    ipl2 <- ipl
}else{
    ipl2	<- unlist(strsplit(ipl2,","))
    if(length(ipl)!=length(ipl2)){stop("list with old and new environmental data layers is not of the same length")}
}
opl	<- Sys.getenv("arrOUT")			# output layers
opl	<- unlist(strsplit(opl,";"))
opi	<- opl[-1]						# base name individual layers
opc	<- opl[1]						# name of MESS layer
vtl <- Sys.getenv("REF_LAY")    	# reference distribution raster layer
rtl <- Sys.getenv("REF_TYPE")		# raster or vector layer
flm	<- Sys.getenv("GIS_FLAG_M")
flk	<- Sys.getenv("GIS_FLAG_K")
fll	<- Sys.getenv("GIS_FLAG_L")
fln	<- Sys.getenv("GIS_FLAG_N")
digits	<- as.numeric(Sys.getenv("GIS_OPT_DIGITS"))	# Precision
digits2 <- 10^digits
options(echo=TRUE, digits=digits+4, scipen=digits+4)

#-----------------------------------------------------------------------
# Create the r.mapcalc expressions to calculate the mess for the 
# individual layers. The main step is to define the recode rules to 
# be used  -  
#-----------------------------------------------------------------------

if(rtl=="R"){
    
    # Reference distribution layer is raster 
    #-----------------------------------------------------------------------  

    for(i in 1:length(ipl)){
        
        # Get the environmental frequency distributions for the reference points in R. 
		
        tmpf0 <- "rmess_tmp_fr9876543210a"
        execGRASS("r.mapcalc", flags="overwrite", expression=paste(tmpf0, "=", vtl, "* 1"))
        
		citiam <- system("g.findfile --quiet element=cell file=MASK", ignore.stdout = TRUE)
        if(citiam==0){
           rname <- paste("MASK",paste(sample(c(0:9, letters, LETTERS), 12, replace=TRUE), collapse=""), sep="_")
           execGRASS("g.copy", rast=paste("MASK", rname, sep=","))
           system("g.remove -bf type=rast name=MASK")
        }

        # Create mask based on combined MASK/input layer
        # Make compatible for both v6.4 and 7
        if(grassversion==7){
            execGRASS("r.mask", raster=tmpf0)
        }else{
            execGRASS("r.mask", input=tmpf0)
        }
 
        # Calculate the frequency distribution 
        tmpf1 <- "rmess_tmp_fr987654321a"
        execGRASS("r.mapcalc", flags="overwrite", expression=paste(tmpf1, " = int(", digits2, "*", ipl[i], ")"))
        frtab <- execGRASS("r.stats", flags=c("c", "n"), input=tmpf1, separator=",", sort="asc", intern=TRUE)
        a <- outputGRASS(frtab, separator=",")
        a <- a[order(a[,1]),]
        b <- cumsum(as.numeric(a[,2]))/sum(a[,2])*100

        tmpf2 <- "rmess_tmp_fr987654321b"
        execGRASS("r.mapcalc", flags="overwrite", expression=paste(tmpf2, " = int(", digits2, "*", ipl2[i], ")"))
        d <- execGRASS("r.univar", map=tmpf2, flags="g", intern=TRUE)
        d <- outputGRASS(d, separator="=")        
        
        # Create recode rules
        minv <- as.numeric(subset(d, select=V2, V1=="min"))
        maxv <- as.numeric(subset(d, select=V2, V1=="max"))
        e1 <- ifelse(minv < min(a[,1]), minv, min(a[,1])-1)
        e2 <- ifelse(maxv > max(a[,1]), maxv, max(a[,1])+1)
        a1 <- c(e1, a[1,1], a[,1]+1)
        a2 <- c(a[1,1], a[,1], e2)
        b1 <- c(0, b, 101)
        b1 <- round(b1*digits2)
        c1 <- cbind(a1,a2, b1)
        xy2 <- apply(c1, 1, function(x){paste(format(x, scientific=FALSE, trim=TRUE), collapse=":")})
        tmp.rule <- tempfile(pattern = "file", tmpdir = tempdir(), fileext = ".rules")
        write.table(xy2, file=tmp.rule, quote=F, row.names=F, col.names=F)
        
        # Restore mask
        if(citiam==0){
            execGRASS("r.mask", flags="overwrite", raster=rname)
            execGRASS("g.remove", flags="f", type="rast", name=rname)
        }else{
            execGRASS("r.mask", flags="r")
        }
        
        # Create the recode layer and calculate the IES
        execGRASS("r.mapcalc", flags="overwrite", expression=paste(tmpf2, " = int(", digits2, "*", ipl2[i], ")"))
        tmpf3 <- "rmess_tmp_fr987654321c"
        execGRASS("r.recode", input=tmpf2, output=tmpf3, rules=tmp.rule, flags="overwrite")
        min1 <- min(a[,1])
        max1 <- max(a[,1])
        thr1 <- format(50*digits2, scientific=FALSE)
        thr2 <- format(100*digits2, scientific=FALSE)
        z1 <- paste("if(", tmpf3, "==0, ", digits2, "* 100.0 * (", tmpf2, "-", min1, ")/(", max1, "-", min1, ")", sep="")
        z2 <- paste(", if(", tmpf3, "<=", thr1, ", 2*", tmpf3, sep="")
        z3 <- paste(", if(", tmpf3, "<=", thr2, ", 2*(", thr2, "-", tmpf3, ")", sep="")
        z4 <- paste(",", digits2, " * 100.0 * (", max1, "- ", tmpf2, ")/(", max1, "-", min1, "))))", sep="")
        calcc <- paste(z1, z2, z3, z4, sep="")
        execGRASS("r.mapcalc", expression=paste(opi[i], " = ", calcc, sep=""), flags="overwrite") 
        execGRASS("r.mapcalc", expression=paste(opi[i], " = ", opi[i], "/", digits2, ".0", sep=""), flags="overwrite")
        execGRASS("g.remove", flags="bf", type="rast", name=paste(tmpf0, tmpf1, tmpf2, tmpf3, sep=","))
        unlink(tmp.rule)
    }
}else{

    # Reference distribution layer is vector 
    #-----------------------------------------------------------------------

    execGRASS("v.extract", flags="t", input=vtl, type="point", output="tmpMESS976543210")
    system(paste("v.db.addtable tmpMESS976543210 columns='", paste(ipn, " double precision", collapse=","), "'", sep=""))

    # make compatible for both v6.4 and 7
    if(grassversion==7){
	for(m in 1:length(ipn)){
	    system(paste("v.what.rast map=tmpMESS976543210 layer=1 raster=", ipl[m], " column=", ipn[m], sep=""))
	}
    }else{
	for(m in 1:length(ipn)){
	    system(paste("v.what.rast vector=tmpMESS976543210 layer=1 raster=", ipl[m], " column=", ipn[m], sep=""))
	}
    }
    
    spld <- paste(ipn, collapse=",")
    b <- execGRASS("v.db.select", parameters=list(map="tmpMESS976543210", columns=spld), intern=TRUE)
    con <- textConnection(b)
    spl <- na.omit(read.table(con, header=TRUE, sep="|"))
    
    # Check for point without values
    clpf <- na.action(spl)
    if(length(clpf)==1){print(paste("Please note that the point", clpf, "has no value. This is probably because it lies outside the current region"))}
    if(length(clpf)>1){print(paste("Please note that the points", paste(clpf, collapse=" and "), "have no values. This is probably because they lie outside the current region"))}
   
    close(con)
    system("g.remove -f type=vect name=tmpMESS976543210")

    for(i in 1:length(ipl)){
      
        # Calculate the frequency distribution 
        a  <- table(spl[i])
        envmin <- min(spl[i])
        envmax <- max(spl[i])
        Drange <- system(paste("r.info -r --verbose map=", ipl2[i], sep=""), intern=T)
        Dmin <- as.numeric(sub("min=", "", Drange[1]))
        Dmax <- as.numeric(sub("max=", "", Drange[2]))
        
        # Create recode rules
        x1 <- c(Dmin, as.numeric(rownames(a)))
        x2 <- c(envmin, as.numeric(rownames(a))[-1],Dmax)
        y1 <- c(0,cumsum(as.numeric(a))/sum(a)*100)
        xy1 <- format(cbind(x1,x2,y1), scientific=F, trim=T, nsmall=digits)
        xy2 <- apply(xy1, 1, function(x){paste(x, collapse=":")})
        tmp.rule <- tempfile(pattern = "file", tmpdir = tempdir(), fileext = ".rules")
        write.table(xy2, file=tmp.rule, quote=F, row.names=F, col.names=F)
        
        # Create the recode layer and calculate the IES
        tmpv1 <- "rmess_tmp_fr987654321v1"
        execGRASS("r.recode", flags="overwrite", input=ipl2[i], output=tmpv1, rules=tmp.rule)
        z1 <- paste("if(", tmpv1, "==0, (double(", ipl2[i], ")-", envmin, ".0)/(", envmax, ".0-", envmin, ".0) *100.0", sep="")
        z2 <- paste(", if(", tmpv1, "<=50, 2.0 * ", tmpv1)
        z3 <- paste(", if(", tmpv1, "<100, 2.0 * (100.0- ", tmpv1, ")")
        z4 <- paste(", (", envmax, ".0- double(",  ipl2[i], "))/(", envmax, ".0-", envmin, ".0) * 100.0)))", sep="")
        calcc <- paste(z1, z2, z3, z4, sep="")
        execGRASS("r.mapcalc", expression=paste(opi[i], "=", calcc), flags="overwrite") 
        execGRASS("g.remove", flags="f", type="rast", name=tmpv1)
        unlink(tmp.rule)
    }
}
#-----------------------------------------------------------------------
# Calculate MESS
#-----------------------------------------------------------------------

system(paste("r.series output=", opc, " input=", paste(opi, collapse=","), " method=minimum", sep=""))

#-----------------------------------------------------------------------
# Calculate other stats
#-----------------------------------------------------------------------

if(fln==1){
	execGRASS("r.mapcalc", expression=paste(opc, "_neg = if(", opc, "<0,1)", sep=""))
}

if(flm==1){
    system(paste("r.series output=", opc, "_MoD input=", paste(opi, collapse=","), " method=min_raster", sep=""))
    nuvto <- length(ipn)-1
    nuv <- cbind(seq(from=0, to=nuvto, by=1), ipn)
    reclvar <- apply(nuv,1,function(x){paste(x[1],x[2], sep=":")})
    tmpclas <- tempfile(pattern = "classification.rules.")
    sink(tmpclas)
    for(i in 1:length(reclvar)){
        cat(reclvar[i]); cat("\n")
    }
    sink()
    system(paste("r.category map=", opc, "_MoD rules=", tmpclas, sep=":"))
    unlink(tmpclas)
}
if(flk==1){
    system(paste("r.series output=", opc, "_mean input=", paste(opi, collapse=","), " method=average", sep=""))
}
if(fll==1){
    system(paste("r.series output=", opc, "_median input=", paste(opi, collapse=","), " method=median", sep=""))
}

EOF
}


# RGrass script generation
# --------------------------
RGRASSSCRIPT="`g.tempfile pid=$$`"
if [ $? -ne 0 ] || [ -z "$RGRASSSCRIPT" ] ; then
	g.message -e 'ERROR: unable to create temporary file for RGrass script' 1>&2
    exit 1
fi
writeScript "$RGRASSSCRIPT"


#=======================================================================
## RGrass call
#=======================================================================

# Message
g.message message='Calculating MESS layers.. this may take some time'

##using R to create MESS layers
# R --no-save --no-restore --no-site-file --no-init-file --args "$arrIN" "${INMAPS1}" "${INMAPS2}" "$arrOUT" "$tmpLY" "$REF_LAY" "$GIS_FLAG_M" "$GIS_FLAG_K" "$GIS_FLAG_L" "$GIS_OPT_DIGITS" "$REF_TYPE" 
R --no-save --no-restore < "$RGRASSSCRIPT" >> "$LOGFILE" 2>&1
if [ $? -ne 0 ] ; then
	echo "ERROR: an error occurred during R script execution" 1>&2
    exit 1
fi

g.message "Finished - you can find the maps in your current mapset"

#=======================================================================

