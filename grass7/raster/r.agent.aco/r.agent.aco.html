<h2>DESCRIPTION</h2>

<em>r.agent</em> shall provide an inital base for organizing worlds
with raster playgrounds and agents in.
<p>
As this is only a first implementation the encapsulation that grants
a modular usage is still suffering..
<p>
<em>r.agent</em> is written in python for more transparency and
better extendability.
<p>
As a first world example there is an ACO-based environment
(see <a href="http://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms">Ant Colony Optimization</a>)
available (in <em>libold</em> see below..).
<p>
The basic concept of such an ACO world, is to take some cost surface
and transform it to a penalty layer - where for human ants for example
this penalty layer may be expressed by the walking velocity, e.g. calculated
with the algorithm proposed by
<a href="http://www.geodyssey.com/papers/tobler93.html">Tobler1993</a>.
The actors on the playground will wander around on the playground
using the time for their paths that correspond with the values in the penalty
grid.
If they find some attractor, they walk home to the position they
originated, marking their way with pheromones. While this
pheromone vanishes over time, the following agents are more likely
to choose their next steps to a position that smells most.
<p>
This first toolset was mainly developed for
<a href="http://www.topoi.org/group/a-iii-4/">Topoi Project A-III-4</a>,
with some
inspirations from previous work conducted at the
<a href="http://www.unibe.ch/">Uni Bern</a> in 2008.


<h2>NOTES</h2>

The state of this software is: "first do it".
This is work in progress and its structure will probably change quite a lot
in the future due to a better integration in GRASS and other refactoring.
<p>
The refactoring causes <em>r.agent</em> to not work for the moment. The general
behaviour can be seen by changeing the imports in <em>r.agent.aco</em>
to the old library <em>libold</em> -- <em>libagent</em> is coming soon.
<p>
Unfortunately the colletion is not very well included in GRASS yet.
At the moment <em>libold</em> only handles ASCII grid and vector in- and
output data. With a better GRASS integration (arrays) not only will the code
get lighter but also these drawbacks shall vanish.
<p>
ACO works best on dynamic maps -- it constantly tries to improve paths...


<h2>EXAMPLE</h2>

A fictive usecase could look something like this
(note: at the moment the
in- and output variables with <em>libold</em>, are still ascii-files):
<p>
<div class="code"><pre>
r.agent.aco outputmap=out.map penaltymap=testpenalty.grid \
  sitesmap=sites.vect rounds=100 outrounds=100 volatilizationtime=5000 \
  antslife=2000 maxants=400 pathintensity=1000000
</pre></div>
<p>
For running the total test suite on the libraries,
i.e. to run all the tests that are at the end
of each python file, use this test collection
(for certain tests, the following files must exist though:
 "elev.grid", and "arch.vect"):
<p>
<div class="code"><pre>
user@host:~$ cd /&lt;pathtoaddons&gt;/r.agent/libagent

user@host:libold$ ./alltests.py
</pre></div>

<h2>TODO</h2>

Integrate it directly within grass.
<p>
Improve encapsulation of classes.
<p>
Find good parameters, or parameter finding strategies for the ACO part.
Try to avoid high penalty fields.
Think about heuristics too.
<p>
Implement other ABM scenarios.

<h2>SEE ALSO</h2>

<h2>AUTHORS</h2>

Michael Lustenberger inofix.ch

<p><i>Last changed: $Date$</i>


